name: Build Documentation (Optimized)

on:
  workflow_call:
    inputs:
      environment_name:
        description: "Environment name for deployment"
        required: true
        type: string
      deployment_type:
        description: "Type of deployment: pr, push, or release"
        required: true
        type: string
      target_branch:
        description: "Target branch for deployment"
        required: false
        type: string
        default: "main"
      version_override:
        description: "Override version (for releases)"
        required: false
        type: string
    outputs:
      deploy-url:
        description: "The deployment URL"
        value: ${{ jobs.build.outputs.deploy-url }}
      version:
        description: "The generated version"
        value: ${{ jobs.build.outputs.version }}
      artifact-name:
        description: "The name of the uploaded artifact"
        value: ${{ jobs.build.outputs.artifact-name }}
permissions:
  contents: read
  pages: write
  id-token: write
jobs:
  build:
    name: Build Documentation (Optimized)
    runs-on: ubuntu-latest
    outputs:
      deploy-url: ${{ steps.finalize.outputs.deploy-url }}
      version: ${{ steps.calver.outputs.version }}
      artifact-name: ${{ steps.finalize.outputs.artifact-name }}
    environment:
      name: ${{ inputs.environment_name }}
      url: ${{ steps.deployment.outputs.page_url }}${{ steps.branch-setup.outputs.path-suffix }}
    defaults:
      run:
        shell: bash -el {0}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for versioning

      - name: Setup branch and paths
        id: branch-setup
        env:
          RAW_REF: ${{ github.head_ref || github.ref_name }}
        run: |
          if [ "${{ inputs.deployment_type }}" = "pr" ]; then
            branch_slug=$(./.github/slugify.sh "$RAW_REF")
            echo "BRANCH_SLUG=$branch_slug" >> $GITHUB_ENV
            echo "path-suffix=$branch_slug" >> $GITHUB_OUTPUT
          elif [ "${{ inputs.deployment_type }}" = "push" ]; then
            echo "BRANCH_SLUG=main" >> $GITHUB_ENV
            echo "path-suffix=" >> $GITHUB_OUTPUT
          else
            # release
            echo "BRANCH_SLUG=release" >> $GITHUB_ENV
            echo "path-suffix=" >> $GITHUB_OUTPUT
          fi

      - name: Generate version
        id: calver
        run: |
          if [ -n "${{ inputs.version_override }}" ]; then
            version="${{ inputs.version_override }}"
          else
            # Generate Calver in YY.M.DD.increment+[git short sha] format (PEP 440 compliant)
            today=$(date +'%y.%m.%d')
            short_sha=$(git rev-parse --short HEAD)

            if [ "${{ inputs.deployment_type }}" == "pr" ]; then
              # For PRs, use hour/minute for uniqueness
              build_num=$(date +'%H%M')
            else
              # For push/release, use a counter based on commits today
              build_num=$(git rev-list --count --since="$(date +%Y-%m-%d)" HEAD)
            fi

            # Use PEP 440 compliant format: YY.M.DD.increment+gitSHA
            version="${today}.${build_num}+${short_sha}"
          fi

          echo "Generated version: $version"
          echo "version=$version" >> $GITHUB_OUTPUT

          # Update setup.py with the version for Sphinx to use
          if [ -f "cli/setup.py" ]; then
            sed -E -i.bak "s/version\s*=\s*['\"][^'\"]*['\"]/version=\"$version\"/" cli/setup.py
            echo "Updated setup.py with version: $version"
          fi

      - name: Cache Conda packages
        uses: actions/cache@v4
        with:
          path: ~/conda_pkgs_dir
          key: conda-${{ runner.os }}-${{ hashFiles('environment.yml') }}
          restore-keys: |
            conda-${{ runner.os }}-

      - name: Install build optimization tools
        run: |
          # Install GNU parallel for optimal parallel builds
          sudo apt-get update
          sudo apt-get install -y parallel
          echo "GNU parallel installed for optimized builds"

      - name: Upgrade conda
        run: |
          conda update -n base -c conda-forge conda -y -q
          conda --version
        shell: bash

      - name: Setup Conda (Optimized)
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-update-conda: false
          python-version: "3.13"
          channels: conda-forge,defaults
          channel-priority: strict
          environment-file: environment.yml
          activate-environment: edbook
          use-mamba: true # Use mamba for faster package resolution
          condarc-file: .condarc

      - name: Cache Sphinx build directories
        uses: actions/cache@v4
        with:
          path: |
            projects/*/build
            projects/*/_build
            projects/*/doctrees
          key: sphinx-cache-${{ runner.os }}-${{ hashFiles('projects/**/*.rst', 'projects/**/*.py', 'projects/**/*.md') }}
          restore-keys: |
            sphinx-cache-${{ runner.os }}-

      - name: üöß Build versioned documentation (Parallel Optimized)
        id: build-versioned
        run: |
          # Build documentation with parallel processing
          mkdir -p versioned-docs/main versioned-docs/${{ env.BRANCH_SLUG }}

          # Pre-create all LIST_OF_HOVER_TERMS.json files
          echo "‚ö° Pre-creating hover terms files..."
          cd projects
          for project in */; do
            if [ -d "$project" ] && [ -f "$project/conf.py" ]; then
              if [ ! -f "$project/LIST_OF_HOVER_TERMS.json" ]; then
                echo "[]" > "$project/LIST_OF_HOVER_TERMS.json"
              fi
              # Validate JSON
              if ! python3 -m json.tool "$project/LIST_OF_HOVER_TERMS.json" > /dev/null 2>&1; then
                echo "[]" > "$project/LIST_OF_HOVER_TERMS.json"
              fi
            fi
          done

          # Create build script for parallel execution
          cat > ../build_project.sh << 'EOF'
          #!/bin/bash
          project="$1"
          branch_slug="$2"

          echo "üî® Building $project..."
          cd "projects/$project"

          # Use optimized Sphinx build options
          sphinx-build -b html \
            -j auto \
            -q \
            --keep-going \
            -D html_show_sourcelink=0 \
            -D html_copy_source=0 \
            . "../../versioned-docs/$branch_slug/$project"

          build_status=$?
          if [ $build_status -eq 0 ]; then
            echo "‚úÖ $project built successfully"
          else
            echo "‚ö†Ô∏è  $project build failed, continuing..."
          fi
          EOF

          chmod +x ../build_project.sh

          # Build projects in parallel (limit to 4 concurrent builds to avoid resource exhaustion)
          echo "üöÄ Starting parallel builds..."
          project_list=""
          for project in */; do
            if [ -d "$project" ] && [ -f "$project/conf.py" ]; then
              project_name=${project%/}
              project_list="$project_list $project_name"
            fi
          done

          cd ..

          # Use GNU parallel if available, otherwise use xargs with limited parallelism
          if command -v parallel >/dev/null 2>&1; then
            echo "Using GNU parallel for optimal performance..."
            echo "$project_list" | tr ' ' '\n' | parallel -j4 ./build_project.sh {} "${{ env.BRANCH_SLUG }}"
          else
            echo "Using xargs for parallel builds..."
            echo "$project_list" | tr ' ' '\n' | xargs -n1 -P4 -I{} ./build_project.sh {} "${{ env.BRANCH_SLUG }}"
          fi

          # For PRs, copy branch builds to main for version comparison
          # (push builds already target versioned-docs/main/ directly via BRANCH_SLUG=main)
          if [ "${{ inputs.deployment_type }}" = "pr" ]; then
            echo "üìÅ Creating main comparison copies..."
            cp -r "versioned-docs/${{ env.BRANCH_SLUG }}/"* versioned-docs/main/
          fi

          echo "üéâ All builds completed!"

      - name: üìä Build Statistics
        run: |
          echo "üìä Build Statistics:"
          echo "Total projects built: $(find versioned-docs/${{ env.BRANCH_SLUG }} -maxdepth 1 -type d | wc -l)"
          echo "Total size: $(du -sh versioned-docs/)"
          echo "Largest projects:"
          du -sh versioned-docs/${{ env.BRANCH_SLUG }}/*/ | sort -hr | head -5

      - name: üìÇ Prepare deployment structure (Optimized)
        run: |
          # Different deployment strategies based on type
          if [ "${{ inputs.deployment_type }}" == "pr" ]; then
            # PR: Create branch-specific structure with forsida as landing page
            if [ -d "versioned-docs/${{ env.BRANCH_SLUG }}/forsida" ] && [ -f "versioned-docs/${{ env.BRANCH_SLUG }}/forsida/index.html" ]; then
              echo "Using forsida project as branch landing page"
              cp -r versioned-docs/${{ env.BRANCH_SLUG }}/forsida/* versioned-docs/${{ env.BRANCH_SLUG }}/

              # Create root redirect to branch (optimized with minimal HTML)
              echo '<!DOCTYPE html>' > versioned-docs/index.html
              echo '<html><head><meta charset="UTF-8"><title>Edbook PR Preview</title>' >> versioned-docs/index.html
              echo "<meta http-equiv=\"refresh\" content=\"0; url=${{ env.BRANCH_SLUG }}/\"></head>" >> versioned-docs/index.html
              echo "<body><p>Redirecting to <a href=\"${{ env.BRANCH_SLUG }}/\">PR preview</a>...</p></body></html>" >> versioned-docs/index.html
            else
              echo "Forsida project not found, using fallback structure"
              echo '<!DOCTYPE html>' > versioned-docs/${{ env.BRANCH_SLUG }}/index.html
              echo '<html><head><meta charset="UTF-8"><title>Edbook PR Preview</title></head>' >> versioned-docs/${{ env.BRANCH_SLUG }}/index.html
              echo '<body><h1>üìö Edbook PR Preview</h1><p>This branch contains updated documentation projects.</p></body></html>' >> versioned-docs/${{ env.BRANCH_SLUG }}/index.html
            fi

          elif [ "${{ inputs.deployment_type }}" == "push" ]; then
            # Push: Prepare for edbook.github.io deployment (forsida as root)
            if [ -d "versioned-docs/main/forsida" ] && [ -f "versioned-docs/main/forsida/index.html" ]; then
              echo "Preparing forsida as root for production deployment"
              mkdir -p _build
              cp -r versioned-docs/main/forsida/* _build/
              cp -r versioned-docs/main/* _build/
              rm -rf _build/forsida  # Remove duplicate
            else
              echo "Forsida not found, copying all projects to build"
              mkdir -p _build
              cp -r versioned-docs/main/* _build/
            fi

          else
            # Release: Create versioned release structure
            echo "Preparing release deployment structure"
            cp -r versioned-docs/main/* versioned-docs/
          fi

      - name: Setup Pages (for PR deployments)
        if: inputs.deployment_type == 'pr'
        uses: actions/configure-pages@v5

      - name: Upload artifact (for PR deployments)
        if: inputs.deployment_type == 'pr'
        id: upload
        uses: actions/upload-pages-artifact@v3
        with:
          path: versioned-docs

      - name: Deploy to GitHub Pages (for PR deployments)
        if: inputs.deployment_type == 'pr'
        id: deployment
        uses: actions/deploy-pages@v4
        with:
          preview: true

      - name: Finalize outputs
        id: finalize
        if: always()
        run: |
          if [ "${{ inputs.deployment_type }}" = "pr" ]; then
            echo "deploy-url=${{ steps.deployment.outputs.page_url }}" >> $GITHUB_OUTPUT
            echo "artifact-name=${{ steps.upload.outputs.artifact_id }}" >> $GITHUB_OUTPUT
          elif [ "${{ inputs.deployment_type }}" = "push" ]; then
            echo "deploy-url=https://edbook.hi.is" >> $GITHUB_OUTPUT
            echo "artifact-name=build-files" >> $GITHUB_OUTPUT
          else
            echo "deploy-url=" >> $GITHUB_OUTPUT
            echo "artifact-name=" >> $GITHUB_OUTPUT
          fi

