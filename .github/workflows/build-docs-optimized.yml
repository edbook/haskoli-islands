name: Build Documentation (Optimized)

on:
  workflow_call:
    inputs:
      environment_name:
        description: 'Environment name for deployment'
        required: true
        type: string
      deployment_type:
        description: 'Type of deployment: pr, push, or release'
        required: true
        type: string
      target_branch:
        description: 'Target branch for deployment'
        required: false
        type: string
        default: 'main'
      version_override:
        description: 'Override version (for releases)'
        required: false
        type: string
    outputs:
      deploy-url:
        description: "The deployment URL"
        value: ${{ jobs.build.outputs.deploy-url }}
      version:
        description: "The generated version"
        value: ${{ jobs.build.outputs.version }}
      artifact-name:
        description: "The name of the uploaded artifact"
        value: ${{ jobs.build.outputs.artifact-name }}

jobs:
  build:
    name: Build Documentation (Optimized)
    runs-on: ubuntu-latest
    outputs:
      deploy-url: ${{ steps.deployment.outputs.page_url }}
      version: ${{ steps.calver.outputs.version }}
      artifact-name: ${{ steps.upload.outputs.artifact-name }}
    environment:
      name: ${{ inputs.environment_name }}
      url: ${{ steps.deployment.outputs.page_url }}${{ steps.branch-setup.outputs.path-suffix }}
    defaults:
      run:
        shell: bash -el {0}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for versioning

      - name: Setup branch and paths
        id: branch-setup
        run: |
          if [ "${{ inputs.deployment_type }}" == "pr" ]; then
            branch_slug=$(./.github/slugify.sh ${{ github.head_ref || github.ref_name }})
            echo "BRANCH_SLUG=$branch_slug" >> $GITHUB_ENV
            echo "path-suffix=$branch_slug" >> $GITHUB_OUTPUT
          elif [ "${{ inputs.deployment_type }}" == "push" ]; then
            echo "BRANCH_SLUG=main" >> $GITHUB_ENV  
            echo "path-suffix=" >> $GITHUB_OUTPUT
          else
            # release
            echo "BRANCH_SLUG=release" >> $GITHUB_ENV
            echo "path-suffix=" >> $GITHUB_OUTPUT
          fi

      - name: Generate version
        id: calver
        run: |
          if [ -n "${{ inputs.version_override }}" ]; then
            version="${{ inputs.version_override }}"
          else
            # Generate Calver in YY.M.DD.increment+[git short sha] format (PEP 440 compliant)
            today=$(date +'%y.%-m.%-d')
            short_sha=$(git rev-parse --short HEAD)
            
            if [ "${{ inputs.deployment_type }}" == "pr" ]; then
              # For PRs, use hour/minute for uniqueness
              build_num=$(date +'%H%M')
            else
              # For push/release, use a counter based on commits today
              build_num=$(git rev-list --count --since="$(date +%Y-%m-%d)" HEAD)
            fi
            
            # Use PEP 440 compliant format: YY.M.DD.increment+gitSHA
            version="${today}.${build_num}+${short_sha}"
          fi
          
          echo "Generated version: $version"
          echo "version=$version" >> $GITHUB_OUTPUT
          
          # Update setup.py with the version for Sphinx to use
          if [ -f "cli/setup.py" ]; then
            sed -i.bak "s/version=\"[^\"]*\"/version=\"$version\"/" cli/setup.py
            echo "Updated setup.py with version: $version"
          fi

      - name: Cache Conda packages
        uses: actions/cache@v4
        with:
          path: ~/conda_pkgs_dir
          key: conda-${{ runner.os }}-${{ hashFiles('environment.yml') }}
          restore-keys: |
            conda-${{ runner.os }}-

      - name: Install build optimization tools
        run: |
          # Install GNU parallel for optimal parallel builds
          sudo apt-get update
          sudo apt-get install -y parallel
          echo "GNU parallel installed for optimized builds"

      - name: Setup Conda (Optimized)
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-update-conda: false
          python-version: 3.10.10
          channels: conda-forge,defaults
          channel-priority: true
          environment-file: environment.yml
          activate-environment: edbook
          use-mamba: true  # Use mamba for faster package resolution

      - name: Cache Sphinx build directories
        uses: actions/cache@v4
        with:
          path: |
            projects/*/build
            projects/*/_build  
            projects/*/doctrees
          key: sphinx-cache-${{ runner.os }}-${{ hashFiles('projects/**/*.rst', 'projects/**/*.py', 'projects/**/*.md') }}
          restore-keys: |
            sphinx-cache-${{ runner.os }}-

      - name: üöß Build versioned documentation (Parallel Optimized)
        id: build-versioned
        run: |
          # Build documentation with parallel processing
          mkdir -p versioned-docs/main versioned-docs/${{ env.BRANCH_SLUG }}
          
          # Pre-create all LIST_OF_HOVER_TERMS.json files
          echo "‚ö° Pre-creating hover terms files..."
          cd projects
          for project in */; do
            if [ -d "$project" ] && [ -f "$project/conf.py" ]; then
              if [ ! -f "$project/LIST_OF_HOVER_TERMS.json" ]; then
                echo "[]" > "$project/LIST_OF_HOVER_TERMS.json"
              fi
              # Validate JSON
              if ! python3 -m json.tool "$project/LIST_OF_HOVER_TERMS.json" > /dev/null 2>&1; then
                echo "[]" > "$project/LIST_OF_HOVER_TERMS.json"
              fi
            fi
          done
          
          # Create build script for parallel execution
          cat > ../build_project.sh << 'EOF'
          #!/bin/bash
          project="$1"
          branch_slug="$2"
          
          echo "üî® Building $project..."
          cd "projects/$project"
          
          # Use optimized Sphinx build options
          sphinx-build -b html \
            -j auto \
            -q \
            --keep-going \
            -D html_show_sourcelink=false \
            -D html_copy_source=false \
            . "../../versioned-docs/$branch_slug/$project" 2>/dev/null
          
          build_status=$?
          if [ $build_status -eq 0 ]; then
            echo "‚úÖ $project built successfully"
          else
            echo "‚ö†Ô∏è  $project build failed, continuing..."
          fi
          EOF
          
          chmod +x ../build_project.sh
          
          # Build projects in parallel (limit to 4 concurrent builds to avoid resource exhaustion)
          echo "üöÄ Starting parallel builds..."
          project_list=""
          for project in */; do
            if [ -d "$project" ] && [ -f "$project/conf.py" ]; then
              project_name=${project%/}
              project_list="$project_list $project_name"
            fi
          done
          
          cd ..
          
          # Use GNU parallel if available, otherwise use xargs with limited parallelism
          if command -v parallel >/dev/null 2>&1; then
            echo "Using GNU parallel for optimal performance..."
            echo "$project_list" | tr ' ' '\n' | parallel -j4 ./build_project.sh {} ${{ env.BRANCH_SLUG }}
          else
            echo "Using xargs for parallel builds..."
            echo "$project_list" | tr ' ' '\n' | xargs -n1 -P4 -I{} ./build_project.sh {} ${{ env.BRANCH_SLUG }}
          fi
          
          # Handle additional builds for different deployment types
          if [ "${{ inputs.deployment_type }}" == "push" ]; then
            echo "üìÅ Creating main archive copies..."
            # For push, copy branch builds to main (faster than rebuilding)
            cp -r versioned-docs/${{ env.BRANCH_SLUG }}/* versioned-docs/main/
          elif [ "${{ inputs.deployment_type }}" == "pr" ]; then
            echo "üìÅ Creating main comparison copies..."
            # For PRs, copy branch builds to main for version comparison
            cp -r versioned-docs/${{ env.BRANCH_SLUG }}/* versioned-docs/main/
          fi
          
          echo "üéâ All builds completed!"

      - name: üìä Build Statistics
        run: |
          echo "üìä Build Statistics:"
          echo "Total projects built: $(find versioned-docs/${{ env.BRANCH_SLUG }} -maxdepth 1 -type d | wc -l)"
          echo "Total size: $(du -sh versioned-docs/)"
          echo "Largest projects:"
          du -sh versioned-docs/${{ env.BRANCH_SLUG }}/*/ | sort -hr | head -5

      - name: üìÇ Prepare deployment structure (Optimized)
        run: |
          # Different deployment strategies based on type
          if [ "${{ inputs.deployment_type }}" == "pr" ]; then
            # PR: Create branch-specific structure with forsida as landing page
            if [ -d "versioned-docs/${{ env.BRANCH_SLUG }}/forsida" ] && [ -f "versioned-docs/${{ env.BRANCH_SLUG }}/forsida/index.html" ]; then
              echo "Using forsida project as branch landing page"
              cp -r versioned-docs/${{ env.BRANCH_SLUG }}/forsida/* versioned-docs/${{ env.BRANCH_SLUG }}/
              
              # Create root redirect to branch (optimized with minimal HTML)
              echo '<!DOCTYPE html>' > versioned-docs/index.html
              echo '<html><head><meta charset="UTF-8"><title>Edbook PR Preview</title>' >> versioned-docs/index.html
              echo "<meta http-equiv=\"refresh\" content=\"0; url=${{ env.BRANCH_SLUG }}/\"></head>" >> versioned-docs/index.html
              echo "<body><p>Redirecting to <a href=\"${{ env.BRANCH_SLUG }}/\">PR preview</a>...</p></body></html>" >> versioned-docs/index.html
            else
              echo "Forsida project not found, using fallback structure"
              echo '<!DOCTYPE html>' > versioned-docs/${{ env.BRANCH_SLUG }}/index.html
              echo '<html><head><meta charset="UTF-8"><title>Edbook PR Preview</title></head>' >> versioned-docs/${{ env.BRANCH_SLUG }}/index.html
              echo '<body><h1>üìö Edbook PR Preview</h1><p>This branch contains updated documentation projects.</p></body></html>' >> versioned-docs/${{ env.BRANCH_SLUG }}/index.html
            fi
            
          elif [ "${{ inputs.deployment_type }}" == "push" ]; then
            # Push: Prepare for edbook.github.io deployment (forsida as root)
            if [ -d "versioned-docs/main/forsida" ] && [ -f "versioned-docs/main/forsida/index.html" ]; then
              echo "Preparing forsida as root for production deployment"
              mkdir -p _build
              cp -r versioned-docs/main/forsida/* _build/
              cp -r versioned-docs/main/* _build/
              rm -rf _build/forsida  # Remove duplicate
            else
              echo "Forsida not found, copying all projects to build"
              mkdir -p _build  
              cp -r versioned-docs/main/* _build/
            fi
            
          else
            # Release: Create versioned release structure
            echo "Preparing release deployment structure"
            cp -r versioned-docs/main/* versioned-docs/
          fi

      - name: Setup Pages (for PR deployments)
        if: inputs.deployment_type == 'pr'
        uses: actions/configure-pages@v5

      - name: Upload artifact (for PR deployments)
        if: inputs.deployment_type == 'pr'
        id: upload
        uses: actions/upload-pages-artifact@v3
        with:
          path: versioned-docs

      - name: Deploy to GitHub Pages (for PR deployments)
        if: inputs.deployment_type == 'pr'
        id: deployment
        uses: actions/deploy-pages@v4
        with:
          preview: true

      - name: Set outputs for push deployments
        if: inputs.deployment_type == 'push'
        id: push-outputs
        run: |
          echo "deploy-url=https://edbook.hi.is" >> $GITHUB_OUTPUT
          echo "artifact-name=build-files" >> $GITHUB_OUTPUT